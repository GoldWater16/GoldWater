# 面试题：你知道数据库有哪些锁吗？

#### 问：乐观锁和悲观锁有什么区别？

答：

**乐观锁：**它认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回用户错误的信息，让用户决定如何去做。实现方式有两种：版本号和时间戳

**悲观锁：**当我们要对一个数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。实现方式：for update

##### 问：乐观锁和悲观锁的使用场景？

答：

**乐观锁使用场景：**事务之间的数据竞争比较小；

**悲观锁使用场景：**用于数据竞争激烈的环境；

##### 问：数据库锁有了解吗？

答：数据库锁有：行级锁、表级锁、页级锁、共享锁、排它锁、意向锁、意向共享锁、意向排它锁、gap锁、next-key 锁；

**行级锁：**在Mysql中是锁定粒度最细的一种锁，只对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突，其加锁粒度最小，但加锁的开销也最大。行级锁分为**共享锁**和**排它锁**。

> 特点：开销大，加锁慢；会出现死锁；锁定粒度最小；发生锁冲突的概率最低，并发度高

**表级锁：**在Mysql中锁定粒度最大的一种锁，只对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分Mysql引擎支持，例如：MYISAM、INNODB；表级锁分为共享锁和排它锁。

> 特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度低

**页级锁：**在Mysql中锁定粒度介于行级锁和表级锁中间，表级锁速度快，但冲突多，行级锁冲突少，但是速度慢。

所以一次锁定相邻的一组记录。应用于BDB引擎。

> 特点：开销和加锁时间介于表锁和行锁之间；特性同表级锁和行级锁中间；

**共享锁：**即S锁，用于不更改或不更新数据的操作（只读操作），如select语句。如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排它锁。获准共享锁的事务只能读数据，不能修改数据。

**排它锁：**即X锁，用于数据修改操作，如insert、update和delete。确保不会同时同一资源进行多重更新。如果事务T对数据A加上排它锁后，则其他事务不能再对A加任何类型的锁。获取到排它锁的事务既能读数据，又能修改数据。

**意向锁：**它属于表级锁；它是由数据库本身完成的，无需程序猿使用代码来申请；其设计目的主要是为了解决InnoDB中行级锁和表级锁共存问题。也就是说，事务A申请一行的行锁的时候，数据库会自动先开始申请表的意向锁；

**意向共享锁(IS)：**表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得该表的IS锁。如果需要对记录A加上共享锁，那么此时InnoDB会先找到这张表，对该表加意向共享锁之后，再对记录A添加共享锁。

**意向排它锁(IX)：**表示事务准备给数据行加入排它锁，也就是说事务在给一个数据行加排它锁前必须先取得该表的IX锁。如果需要对记录A加排它锁，那么此时InnoDB会先找到这张表，对该表加意向排它锁之后，再对记录A添加排它锁。

**gap锁：**即间隙锁；锁定索引记录间隙，确保索引记录的间隙不变。间隙锁是针对事务隔离级别为可重复读或以上级别。作用：防止间隙内有新数据被插入；防止已存在的数据，更新成间隙内的数据。

**next-key 锁：**行锁和间隙锁组合起来就叫next-key 锁。

##### 问：数据库锁和事务隔离级别有什么关系？

答：数据库锁的程度和并发能力是有不同的”事务隔离级别“来控制的。

答：隔离级别由高到底依次为：可序列化(Serializable)、可重复读(Repeatable read)、读已提交(Read committed)、读未提交(Read uncommitted)

##### 问：数据库锁和索引有什么关系？

答：在Mysql中，行级锁并不是直接锁记录，而是锁索引。索引分为主键索引和非主键索引两种，如果一条sql语句操作了主键索引，Mysql就会锁定这条主键索引；如果一条语句操作了非主键索引，Mysql会先锁定该非主键索引，再锁定相关主键索引。

##### 问：什么是聚簇索引？非聚簇索引？最左前缀是什么？联合索引？回表？

答：

聚簇索引：在InnoDB中，主键索引也被称为聚簇索引，主键索引的叶子节点存的是整行数据。

非聚簇索引：在InnoDB中，非主键索引也被称为非聚簇索引，非主键索引的叶子节点的内容是主键的值。

最左前缀：当我们创建一个**联合索引**的时候，如果(key1,key2,key3)，相当于创建了(key1)、(key1,key2)、(key1,key2,key3)三个索引，这就是最左匹配原则。

回表：在InnoDB中，索引B+ 树的叶子节点存储了整行数据的是**主键索引**。而索引B+树的叶子节点存储了主键的值得是**非主键索引**。因为主键索引树的叶子节点直接就是我们要查询的整行数据了，而非主键索引的叶子节点存的是主键的值，查到主键的值以后，还需要再通过主键的值再进行一次查询，这个过程就叫回表。

参考：

https://www.hollischuang.com/archives/934

https://www.cnblogs.com/nickup/p/9804020.html

https://www.csdn.net/gather_27/MtTaMgwsMjU1NS1ibG9n.html

https://www.jianshu.com/p/0468cf485e11

























