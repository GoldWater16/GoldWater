### 怒怼面试官系列之索引的最佳实践

&emsp;&emsp;如果有一天，面试官问你，索引都有哪些规范？说说索引的最佳实践？这时候，你不知道就凉凉了，还是回家好好看看我这篇文章，说不定可以回击面试官。

#### 解释

##### 1、什么是索引？

**答：**索引时数据库表中一列或多列的值进行排序的一种结构，使用索引可以快速访问数据库表中的特定信息。主要目的就是加快检索表中数据。

##### 2、为什么要用索引？

**答：**① 索引能极大的减少存储引擎需要扫描的数据量；

&emsp;&emsp;② 索引可以把随机IO变成顺序IO；

&emsp;&emsp;③ 索引可以帮助我们在进行分组、排序等操作时，避免使用临时表；

##### 3、索引类型有哪些？

**答：**fulltext、hash、btree、rtree

##### 4、索引种类有哪些？

**答：**普通索引、唯一索引、主键索引、组合索引、全文索引

##### 5、创建索引的时机？

**答：**一般情况下，在where、order by和join中出现的列需要建立索引，但是不完全是，因为mysql只对<,>,=,between,in，以及like 'aaa%'才会使用索引

#### 规范

##### 规范一：

&emsp;&emsp;业务上具有唯一特性的字段，即使是多个字段组合，也必须建立唯一索引。

> 不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查询速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据存在。

##### 规范二：

&emsp;&emsp;超过三个表禁止join。需要join的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。

> 即使多表join也要注意表索引、sql性能。

##### 规范三：

&emsp;&emsp;在varchar字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。

> 索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为20的索引，区分度会高达90%以上，可以使用count(distinct left(列名,索引长度))/count(*)的区分度来确定。

##### 规范四：

&emsp;&emsp;页面搜索严禁左模糊或全模糊，如果需要请走索引擎来解决。

> 索引文件具有b-tree的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。

##### 规范五：

&emsp;&emsp;如果有order by 的场景，请注意利用索引的有序性。order by最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现file_sort的情况，影响查询性能。

> 正例：where a=? and b=? order by c;索引：a_b_c
>
> 反例：索引中有范围查找，那么索引有序性无法利用，如：where a>10 order by b;索引：a_b无法排序

##### 规范六：

&emsp;&emsp;利用覆盖索引来进行查询操作，避免回表。

> 如果一本书需要知道第11章是什么标题，会翻开第11章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。
>
> 正例：能够建立索引的种类分为主键索引、唯一索引、普通索引三种，而覆盖索引只是一种查询的一种效果，用explain的结果，extra列中会出现：using index。

##### 规范七：

&emsp;&emsp;利用延迟关联或者子查询优化超多分页场景。

> mysql并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的低了，要么控制返回的总页数，要么对超过特定阈值的页数进行sql改写。
>
> 正例：先快速定位需要获取的id段，然后再关联：select a.* from table a,(select id from table where 条件 limit 10000000,20) b where a.id=b.id

##### 规范八：

&emsp;&emsp;sql性能优化的目标：至少要达到range级别，要求是ref级别，如果可以是consts最好。

> 1、consts单表中最多一个匹配行（主键或唯一索引），在优化阶段即可读取到数据。
>
> 2、ref指的是使用普通的索引（normal index）。
>
> 3、range 对索引进行范围检索。
>
> ```
> 性能优先级依次从最优到最差分别为：system>const>eq_ref>ref>fulltext>ref_or_null>index_merge>unique_subquery>index_subquery>range>index>all
> 1.null:mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。
> 2.const、system：mysql能对查询的某部分进行优化并将其转化成一个常量（可以看show warnings的结果）。 
> 3.eq_ref：primary key 或unique key索引的所有部分被连接使用，最多只会返回一条符合条件的记录。 
> 4.ref：相比eq_ref，不实用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要喝某个值相比较，可能会找到符合条件的行。
> 5.ref_or_null：类似ref，但是可以搜索值为null的行。
> 6.index_merge：表示使用了索引合并的优化方法。
> 7.range：范围扫描通常出现在in(),between,>,<,>=等操作中。
> 8.index：和all一样，不同就是mysql只需扫描索引树，这通常比all快一些。
> 9.all：全表扫描，意味着mysql需要从头到尾去查找所需要的行，通常情况下这需要增加索引来进行优化了。
> ```

##### 规范九：

&emsp;&emsp;建立组合索引的时候，区分度最高的在最左边。

> 正例：如果where a = ? and b = ? ，a列的几乎接近于唯一值，那么只需要单建idx_a索引即可。
>
> 说明：存在非等号和等号混合判断条件时，在建立索引时，请把等号条件的列前置。如：where a > ? and b = ? 那么即使a的区分度更高，也必须把b放在索引的最前列。

##### 规范十：

&emsp;&emsp;防止因字段类型或者字符集不同造成的隐式转换，导致索引失效。

##### 规范十一：

&emsp;&emsp;创建索引时避免有如下极端误解：

> 1、宁滥勿缺：认为一个查询就需要建立一个索引。
>
> 2、宁缺勿滥：任务索引会消耗空间、严重拖慢更新和新增速度。
>
> 3、抵制唯一索引，认为业务的唯一性一律需要在应用层通过“先查后插”方式解决。



参考：

1、https://blog.csdn.net/liutong123987/article/details/79384395

2、阿里巴巴开发手册
