# 如何正确访问redis中海量数据

#### 目录

1. 前言
2. 事故产生
3. 分析原因
4. 解决方案
5. 总结

#### 前言

有时候我们需要知道线上的`redis`的使用情况，尤其需要知道一些前缀的`key`值，那我们怎么去查看呢？

#### 事故产生

因为我们的用户`token`缓存是采用了【user_token:userid】格式的`key`，保存用户的`token`的值。

我们运维为了帮助开发小伙伴们查一下线上现在有多少登录用户，直接用了`keys user_token*`方式进行查询。

事故就此发生了。导致**`redis`不可用，假死。**

#### 分析原因

我们线上的登录用户有几百万，数据量比较多；**`keys`算法是遍历算法**，**复杂度是O(n)**，也就是数据越多，时间复杂度越高。

数据量达到几百万，`keys`这个指令就会导致 `Redis` 服务卡顿

因为 Redis 是单线程程序，顺序执行所有指令，其它指令必须等到当前的 keys 指令执行完了才可以继续。

#### 解决方案

那我们如何去**遍历大数据量**呢？

这个也是**面试经常问的**。我们可以采用redis的另一个**命令`scan`。**我们看一下**`scan`的特点**

> 1、**复杂度虽然也是 O(n)**，但是它是通过游标分步进行的，**不会阻塞线程**
>
> 2、提供 count 参数，不是结果数量，是redis单次遍历字典槽位数量(约等于)
>
> 3、同 keys 一样，它也提供模式匹配功能;
>
> 4、服务器不需要为游标保存状态，游标的唯一状态就是 **scan 返回给客户端的游标整数**;
>
> 5、返回的结果**可能会有重复，需要客户端去重复**，这点非常重要;
>
> 6、单次返回的结果是空的并不意味着遍历结束，而要看**返回的游标值是否为零**

**1、`scan`命令格式**

```
SCAN cursor [MATCH pattern] [COUNT count]
```

**2、命令解释：**`scan` 游标 MATCH <返回和给定模式相匹配的元素> count 每次迭代所返回的元素数量

> SCAN命令是**增量的循环**，每次调用只会**返回一小部分的元素**。所以不会让redis假死
>
> SCAN命令返回的是一个游标，**从0开始遍历，到0结束遍历**

**3、举例**

```java
redis > scan 0 match user_token* count 5
 1) "6"
 2) 1) "user_token:1000"
 2) "user_token:1001"
 3) "user_token:1010"
 4) "user_token:2300"
 5) "user_token:1389"
```

从0开始遍历，返回了游标6，又返回了数据，继续scan遍历，就要从6开始

```java
redis > scan 6 match user_token* count 5
 1) "10"
 2) 1) "user_token:3100"
 2) "user_token:1201"
 3) "user_token:1410"
 4) "user_token:5300"
 5) "user_token:3389"
```

# 总结

这个是**面试经常会问到的**，也是我们小伙伴在**工作的过程经常用的**，如果使用不当，可能会发生重大事故，慎用`keys`，巧用`scan`