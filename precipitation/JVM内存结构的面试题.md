[1、JVM管理的内存结构是怎么样的？]( #title1)

[2、不同的虚拟机在实现运行时内存的时候有什么区别？]( #title2)

[3、运行时数据区中哪些区域是线程共享的？哪些是独享的？]( #title3)

[4、除了JVM运行时内存外，还有什么区域可以用吗？]( #title4)

[5、堆和栈的区别是什么？]( #title5)

[6、Java中的数组是存储在堆上还是栈上的？]( #title6)

[7、Java中的对象创建有多少种方式？]( #title7)

[8、Java中对象创建的过程是怎么样的？]( #title8)

[9、Java中的对象一定在堆上分配内存吗？]( #title9)

[10、如何获取堆和栈的dump文件？]( #title10)



### JVM内存结构的面试题

#### <a id="title1">1、JVM管理的内存结构是怎么样的？</a>
**答：** 如图：

![images](https://github.com/GoldWater16/GoldWater/blob/master/precipitation/images/多线程并发安全原理图片/JVM内存结构图.png)

#### <a id="title2">2、不同的虚拟机在实现运行时内存的时候有什么区别？</a>
**答：** 在《Java虚拟机规范》定义的JVM运行时所需的内存区域，不同的虚拟机实现上有所不同，而在这么多区域中，规范对于方法区的管理是最宽松的，规范中关于这部分的描述如下：

```
方法区在虚拟机启动的时候创建，虽然方法区是堆的逻辑组成部分，但是简单的虚拟机实现可以选择在这个区域不实现垃圾收集与压缩。本版本的规范也不限定实现方法区的内存位置和代码编译的管理策略。方法区的容量可以是固定的，也可以随着程序执行的需求动态扩展，并在不需要过多的空间时自行收缩。方法区在实际内存空间站可以是不连续的。
```

这个规定，可以说是给了虚拟机厂商很大的自由。

虚拟机规范对方法区实现的位置并没有明确要求，在最著名的HotSopt虚拟机实现中（在Java8之前）方法区仅是逻辑上的独立区域，在物理上并没有独立于堆而存在，而是位于永久代中。所以，这时候方法区也是可以被垃圾回收的。

```
实践证明，JVM中存在着大量的声明短暂的对象，还有一些生命周期比较长的对象。为了对他们采用不同的收集策略，采用了分代收集算法，所以Hotspot虚拟机根据对象的年龄不同，把堆分为新生代、老年代和永久代
```

在Java8中，HotSpot虚拟机移除了永久代，使用本地内存来存储类元数据信息并称之为：元空间（Metaspace）

#### <a id="title3">3、运行时数据区中哪些区域是线程共享的？哪些是独享的？</a>

**答：**在JVM运行时内存区域中，程序计数器、虚拟机栈和本地方法栈是**线程私有的**；而Java堆、方法区是**线程共享的**。[什么是TLAB？]( #TLAB)

#### <a id="title4">4、除了JVM运行时内存外，还有什么区域可以用吗？</a>

**答：** 除了我们前面介绍的虚拟机运行时数据区以外，还有一部分内存也被频繁使用，他不是运行时数据区，也不是Java虚拟机规范中定义的内存区域，他就是——直接内存。

直接内存的分配不受Java堆大小的限制，但是他还是会收到服务器总内存的影响。

在JDK1.4中引入的NIO中，引入一种基于Channel和Buffer的I/O方式，他可以使用Native函数直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的应用进行操作。

![images](https://github.com/GoldWater16/GoldWater/blob/master/precipitation/images/多线程并发安全原理图片/堆外内存分配图.png)

#### <a id="title5">5、堆和栈的区别是什么？</a>

**答：** 堆是线程共享的，主要存放对象实例；

栈是线程独享的，主要存放各种基本数据类型、对象引用；

#### <a id="title6">6、Java中的数组是存储在堆上还是栈上的？</a>

**答：** 同其他对象一样，实例是存在堆中，数组的引用是存在栈上

#### <a id="title7">7、Java中的对象创建有多少种方式？</a>

**答：** 

一共有五种：

1. new关键字
2. 反射机制
3. clone
4. 反序列化
5. Constructor类的newInstance

#### <a id="title8">8、Java中对象创建的过程是怎么样的？</a>

**答：** 对于一个普通的Java对象的创建，大致过程如下：

1. 虚拟机遇到new指令，到常量池定位到这个类的符号引用。
2. 检查符号引用代表的类是否被加载、解析、初始化过。
3. 虚拟机为对象分配内存。
4. 虚拟机将分配到的内存空间都初始化为零值（程序能访问到这些字段的数据类型所对应的零值）。
5. 虚拟机对对象进行必要的设置。
6. 执行方法，成员变量进行初始化。

#### <a id="title9">9、Java中的对象一定在堆上分配内存吗？</a>

**答：** 前面我们说过，Java堆中主要保存了对象实例，但是，随着JIT编译期的发展与逃逸分析技术逐渐成熟，站上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到对上也渐渐变得不那么绝对了。

其实，在编译期间，JIT会对代码做很多优化。其中有一部分优化的目的就是减少内存堆分配压力，其中一种重要的技术叫做逃逸分析。如果JIT经过逃逸分析，发现有些对象没有逃逸出方法，那么有可能堆内存分配会被优化成栈内分配。

#### <a id="title10">10、如何获取堆和栈的dump文件？</a>

**答：** Java Dump，即Java虚拟机的运行时快照。将Java虚拟机运行时的状态和信息保存到文件。

**获取堆dump：**

可以使用在服务器上使用jmap命令来获取堆的dump；

**获取栈dump：**

使用jstack命令来获取线程的调用栈dump：



## 说明：

##### <a id="TLAB">什么是TLAB？</a>

**答：** 为了保证Java对象的内存分配的安全性，同时提升效率，每个线程在Java堆中可以预先分配一小块内存，这部分内存称之为TLAB（Thread Local Allocation Buffer），这块内存的分配时线程独占的，读取、使用、回收是线程共享的。可以通过设置-XX:/-UseTLAB参数来指定是否开启TLAB分配。

##### Java对象的内存是如何分配的？

**答：** 我们都知道，Java是一门面向对象的语言，我们在Java中使用的对象都需要被创建出来，在Java，创建一个对象的方法有很多种，如使用new、反射、clone方法等，但是无论如何，对象在创建过程中，都需要进行内存分配。

我们拿最常见的new关键字举例，当我们使用new创建对象后代码开始运行，虚拟机执行到这条new指令的时候，会先检查要new的对象对应的类是否已被加载，如果没有被加载则先进行类加载。

在类加载检查通过之后，就需要给对象进行内存分配了，分配的内存主要用来存放对象的实例变量。

在进行内存分配时，需要根据对象中的实例变量情况等信息确定需要分配的空间大小，然后从Java堆中划分出这样一块区域（假设没有JIT优化）。

我们知道，对象的内存分配过程中，主要是对象的引用指向这个内存区域，然后进行初始化操作。那么问题来了，在并发场景中，如何内存分配过程的线程安全性？如果两个线程先后把对象引用指向了同一个内存区域怎么办。

**一般有两种解决方案：**

**1、对分配内存空间的动作做同步处理，采用CAS机制，配合失败重试的方式保证更新操作的线程安全性；**

**2、每个线程在Java堆中预先分配一小块内存，然后再给对象分配内存的时候，直接在自己这块”私有“内存中分配，当这部分区域用完之后，再分配新的”私有“内存。**

显然，第一个方案在每次分配时都需要进行同步控制，这种是比较低效的。第二个方案是Hotspot虚拟机中采用的方案，这种方案被称之为TLAB分配，即Thread Local Allocation Buffer）。这部分Buffer是从堆中划分出来的，但是是本地线程独享的。

**这里值得注意的是，我们说TLAB时线程独享的，但是只是在”分配“这个动作上是线程独占的，至于在读取、垃圾回收等动作上都是线程共享的。而且在使用上也没有什么区别。**

另外，TLAB仅作用于新生代的Eden Space，对象被创建的时候首先放到这个区域，但是新生代分配不了内存的大对象会直接进入老年代。因此在编程Java程序时，通常多个小的对象比大的对象分配起来更加高效。

所以，虽然对象刚开始可能通过TLAB分配内存，存放在Eden区，但是还是会被垃圾回收或者被移到Survivor Space、Old Gen等。

不知道大家有没有想过，我们使用了TLAB之后，在TLAB上给对象分配内存时是线程独享的，但是TLAB这块内存自身从堆中划分出来的过程也可能存在内存安全问题。怎么办呢？

所以，在对于TLAB的分配过程中，还是需要进行同步控制的。但是这种开销相比方案1每次为单个对象划分内存时候对进行同步控制的要低的多。



