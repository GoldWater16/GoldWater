# Java面试通过宝典（七）

#### 问：StringBuffer，StringBuilder的区别？

答：StringBuffer是线程安全的，StringBuilder是非线程安全的；

##### 问：什么是线程安全？

答：维基百科解释：是多线程编程时的计算机程序代码中的一个概念。在拥有共享数据的多条线程并行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。

##### 问：如何保证线程安全？

答：通常使用synchronized和lock加锁来保证线程安全；

##### 问：什么是死锁？

答：死锁是指两个或两个以上的进程都在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，他们都将无法推进下去。此时称系统处于死锁状态或系统产生死锁。

##### 问：产生死锁的必要条件是什么？

答：互斥条件、请求和保持条件、不剥夺条件、循环等待；

##### 问：如何预防死锁？

答：破坏上述四个条件其中一个或多个；

##### 问：如何避免死锁？

答：避免是指进程在每次申请资源时判断这些操作是否安全，典型算法是“银行家算法”，但是这种算法会增加系统的开销；具体可看：https://www.cnblogs.com/hujinshui/p/10363087.html

##### 问：synchronized的实现原理是什么？

答：它有两种实现方式：①作用在方法上，底层在JVM采用ACC_SYNCHRONIZED标记符来实现同步；②作用在代码块上，底层在JVM采用monitorenter和monitorexit两个指令来实现同步；更多可参考：https://www.cnblogs.com/hujinshui/p/9990173.html

##### 问：有了synchronized，还要volatile干嘛？

答：volatile通常被比喻成“轻量级的synchronized”，volatile可以保证可见性和有序性，实现原理是通过内存屏障来实现的。volatile有一个重要的作用是sychronized无法做到的，那就是禁止指令重排序。

##### 问：synchronized的锁优化是怎么回事？

答：在jdk6时，HotSpot虚拟机开发团队在这个版本对java中的锁进行优化，如适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁，这些技术都是为了在线程之间更高效的共享数据，以及解决竞争问题。

##### 问：什么是JMM？

答：它是Java内存模型（Java Memory Model,JMM)是一种符合内存模型规范的，，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。

##### 问：Java并发包了解吗？

答：java.util.concurrent包（J.U.C）中包含的是java并发编程中的一些工具类，包括以下四部分：

1. locks部分：包含在java.util.concurrent.locks保重，提供显示锁（互斥锁和读写锁）相关功能；
2. atomic部分：包含在java.util.concurrent.atomic包中，提供原子变量类相关的功能，是构建非阻塞算法的基础；
3. executor部分：散落在java.util.concurrent包中，提供线程池相关的功能；
4. collections部分：散落在java.util.concurrent包中，提供并发容器相关功能；
5. tools部分：散落在java.util.concurrent包中，提供同步工具类，如信号量、闭锁、栅栏等功能；

##### 问：什么是fail-fast？什么是fail-safe？

答：fail-fast机制，默认指的是Java集合的一种错误检测机制。当多个线程对部分集合进行结构上的改变的操作时，有可能会产生fail-fast机制，这个时候就会抛出ConcurrentModificationException。

为了避免触发fail-fast机制，导致异常，我们可以使用Java中提供的一些采用了fail-safe机制的集合类。

这样的集合容器在遍历时不时直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。

java.util.concurrent包下的容器都是fail-safe的，可以在多线程下并发使用，并发修改。同时也可以在foreach中进行add或remove。

##### 问：什么是CopyOnWrite？

答：Copy-On-Write简称COW，是一种用于程序设计中的优化策略。

原理是：当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完之后，再将原容器的引用指向新的容器。

##### 问：什么是AQS？

答：AQS全称是AbstractQueueSynchronized，它是一个同步工具也是Lock用来实现线程同步的核心组件；

##### 问：说说AQS的原理？

答：AQS队列内部维护的是一个FIFO的双向链表，这种结构的特点是每个数据结构都有两个指针，分别指向后继节点和前驱节点。每个Node都是由线程封装，当线程争抢锁失败后会封装成Node加入到AQS队列中去，当获取锁线程释放锁以后，会从队列中唤醒一个阻塞的节点（线程）。

##### 问：什么是CAS？

答：CAS是一种乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其他线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。

CAS操作包含三个操作数：内存位置（V）、预期原值（A）和新值（B）；如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。



**由于篇幅所限，后续再介绍更多经典的面试题。**

**如果觉得写得不错，可以扫描下方二维码进行关注。**























