#  MySQL 军规

军规整理来源：

- [再议数据库军规](http://www.10tiao.com/html/249/201702/2651959910/1.html)
- [赶集mysql军规](http://www.10tiao.com/html/249/201712/2651960775/1.html)
- [58到家数据库30条军规解读](http://www.10tiao.com/html/249/201702/2651959906/1.html)

---

## 一、基础规范

### 1 必须使用 InnoDB 存储引擎

支持事务、行级锁、并发性能更好、CPU 及内存缓存页优化使得资源利用率更高。

### 2 必须使用 UTF8 字符集，新库使用 UTF8mb4 字符集

UTF8mb4 是 UTF8 的超集，Emoji 表情以及部分不常见汉字在 UTF8 下会表现为乱码，故需要升级至 UTF8mb4。默认使用这个字符集的原因是：“标准，万国码，无需转码，无乱码风险”，并不“节省空间”。

### 3 数据表、数据字段必须加入中文注释

N 年后谁 TM 知道这个 r1,r2,r3 字段是干嘛的。

### 4 禁止使用存储过程、视图、触发器、Event

高并发大数据的互联网业务，架构设计思路 ”解放数据库 CPU，将计算转移到服务层“，并发量大的情况下，这些功能很可能将数据库拖死，业务逻辑放到服务层具备更好的扩展性，能够轻易实现 “增机器就加性能”。数据库擅长存储与索引，CPU 计算还是上移吧。

### 5 禁止存储大文件或者大照片

为何要让数据库做它不擅长的事情？大文件和照片存储在文件系统，数据库里存 URI 多好。

---

## 二、核心规范

### 1 不在数据库做计算，CPU 计算务必移至业务层

尽量不要使用 case when，DATEDIFF 等复杂的函数。如果访问量特别的大，数据内容特别的多，很容易造成速度变慢，甚至数据库的崩溃。如果只是公司内部用，访问量不大，还是没关系的。越大型的项目越不要用这些复杂的 SQL 语句，尽量将所有数据都查出来，在代码中进行处理。

### 2 控制单表数据量，单表记录控制在千万级

当数据库单表数据量达到一定程度时，数据查询变得很慢很慢，建立索引已经无法提高查询速度。

### 3 控制列数量，字段数控制在 20 以内

数据是按页存储的，一个数据页只有 8K，当字段过多时，将导致数据页可容纳的行数减少，对同样的记录数，将需要更多的数据页来存储数据，这对查询以及有条件的 DELETE、UPDATE 将有严重的影响。

### 4 平衡范式与冗余，为提高效率可以牺牲范式设计，冗余数据

参考 [
数据库设计之范式与冗余设计](https://blog.csdn.net/elemman/article/details/50966164)

### 5 拒绝 3B(big)，大 sql，大事务，大批量

---

## 三、字段类军规

### 1 用好数值类型

1. tinyint(1 Byte)
2. smallint(2 Byte)
3. mediumint(3 Byte)
4. int(4 Byte)
5. bigint(8 Byte)
6. bad case：int(1) / int(11)

### 2 合理定义字段类型

1. 能用数字类型就不用字符类型，用 int 而不是 char(15) 存储 ip。
2. 必须使用 varchar(20) 存储手机号。
    1. 涉及到区号或者国家代号，可能出现 +-() 。
    2. 手机号会去做数学运算么？
    3. varchar 可以支持模糊查询，例如：`like“138%”`
3. 禁止使用小数存储货币。
    1. 使用整数吧，小数容易导致钱对不上。

### 3 慎用 TEXT、BLOB 类型

会浪费更多的磁盘和内存空间，非必要的大量的大字段查询会淘汰掉热数据，导致内存命中率急剧降低，影响数据库性能。

### 4 必须把字段定义为 NOT NULL 并且提供默认值

1. NULL 的列使索引 / 索引统计 / 值比较都更加复杂，对 MySQL 来说更难优化。
2. NULL 这种类型 MySQL 内部需要进行特殊处理，增加数据库处理记录的复杂性；同等条件下，表中有较多空字段的时候，数据库的处理性能会降低很多。
3. NULL 值需要更多的存储空，无论是表还是索引中每行中的 NULL 的列都需要额外的空间来标识。
4. 对 NULL 的处理时候，只能采用 IS NULL 或 IS NOT NULL，而不能采用 =、IN、<、<>、!=、NOT IN 这些操作符号。如：`WHERE name != ’shenjian’`，如果存在 name 为 NULL 值的记录，查询结果就不会包含 name 为 NULL 值的记录。

---

## 四、索引类军规

### 1 单表索引建议控制在 5 个以内

### 2 索引一定不是越多越好（能不加就不加，要加的一定得加）

### 3 单索引字段数不允许超过 5 个

字段超过 5 个时，实际已经起不到有效过滤数据的作用了。

### 4 建立组合索引，必须把区分度高的字段放在前面

能够更加有效的过滤数据。

### 5 禁止在更新十分频繁、区分度不高的属性上建立索引

1. 更新会变更 B+ 树，更新频繁的字段建立索引会大大降低数据库性能。
2. “性别” 这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性能与全表扫描类似。

### 6 字符字段考虑建前缀索引

前缀索引能有效减小索引文件的大小，提高索引的速度。但是前缀索引也有它的坏处：不能在 ORDER BY 或 GROUP BY 中使用前缀索引，也不能把它们用作覆盖索引(Covering Index)。

参考：[前缀索引，一种优化索引大小的解决方案](https://www.cnblogs.com/studyzy/p/4310653.html)

### 5 InnoDB 主键合理使用自增列

1. 主键建立聚簇索引
2. 主键不应该被修改
3. 字符串不应该做主键
4. 如果不指定主键，innodb 会使用唯一且非空值索引代替

---

## 五、SQL 类军规

### 1 SQL 语句尽可能简单

1. 一条 SQL 只能在一个 CPU 运算。
2. 大语句拆小语句，减少锁时间。
3. 一条大 SQL 可以堵死整个库。

### 2. 避免使用触发器，用户自定义函数，请由程序取而代之

### 3 禁止使用 `SELECT *`，只获取必要的字段，需要显示说明列属性

1. 读取不需要的列会增加 CPU、IO、NET 消耗。
2. 不能有效的利用覆盖索引。
3. 使用 `SELECT *` 容易在增加或者删除字段后出现程序 BUG。

### 4 禁止使用 `INSERT INTO t_xxx VALUES(xxx)`，必须显示指定插入的列属性

容易在增加或者删除字段后出现程序BUG

### 5 禁止使用属性隐式转换

`SELECT uid FROM t_user WHERE phone=13812345678` 会导致全表扫描，而不能命中 phone 索引，猜猜为什么？

phone 是 varchar 类型，SQL 语句带入的是整形，故不会命中索引，加个引号就好了：`SELECT uid FROM t_user WHERE phone=’13812345678’`

### 6 禁止在 WHERE 条件的属性上使用函数或者表达式

`SELECT uid FROM t_user WHERE from_unixtime(day)>='2017-02-15'` 会导致全表扫描。

正确的写法是：`SELECT uid FROM t_user WHERE day>= unix_timestamp('2017-02-15 00:00:00')`

### 7 禁止负向查询，以及 % 开头的模糊查询

1. 负向查询条件：NOT、!=、<>、!<、!>、NOT IN、NOT LIKE等，会导致全表扫描。
2. % 开头的模糊查询，会导致全表扫描。

此军规争议比较大，部分网友反馈不这么做很多业务实现不了，稍微解释一下：

一般来说，WHERE 过滤条件不会只带这么一个“负向查询条件”，还会有其他过滤条件，举个例子：查询沈剑已完成订单之外的订单（好拗口）：

`SELECT oid FROM t_order WHERE uid=123 AND status != 1;`

订单表 5000w 数据，但 uid=123 就会迅速的将数据量过滤到很少的级别（uid 建立了索引），此时再接上一个负向的查询条件就无所谓了，扫描的行数本身就会很少。

但如果要查询所有已完成订单之外的订单：

`SELECT oid FROM t_order WHERE status != 1;`

这就挂了，立马 CPU 100%，status 索引会失效，负向查询导致全表扫描。

### 8 禁止大表使用 JOIN 查询，禁止大表使用子查询

会产生临时表，消耗较多内存与 CPU，极大影响数据库性能

### 9 禁止使用 OR 条件，必须改为 IN 查询

旧版本 MySQL 的 OR 查询是不能命中索引的，即使能命中索引，为何要让数据库耗费更多的 CPU 帮助实施查询优化呢？

### 10 OR 改写为 UNION ALL

参考：[or 改写为 union all 性能提升 n 倍](https://blog.csdn.net/yws_1990/article/details/51296515)

### 11 优化 LIMIT 分页

当偏移量非常大的时候，例如可能是 LIMIT 10000,20这样的查询，这时 MySQL 需要查询 10020 条然后只返回最后 20 条，前面的 10000 条记录都将被舍弃，这样的代价很高。如果所有的页面被访问的频率相同，那么这样的查询平均需要访问半个表的数据。要优化这样的查询，要么实在页面中限制分页的数量，要么是优化大偏移量的性能。

参考：[Mysql limit 优化，百万至千万级快速分页，--复合索](https://blog.csdn.net/songyanjun2011/article/details/7308455)


